# JVM内存模型以及各个分区知识

---

GC 的两种判定方法

Minor GC 与 Full GC 分别在什么时候发生？

类加载的几个过程

JVM 内存分哪几个区，每个区的作用是什么

如和判断一个对象是否存活?(或者 GC 对象的判定方法）

java 中垃圾收集的方法有哪些?

什么是类加载器，类加载器有哪些?

类加载器双亲委派模型机制？

什么情况下会发生栈内存溢出？

怎么打破双亲委派模型？

强引用、软应用、弱引用、虚引用的区别？



## JVM的内存模型

JVM时Java Virtual Machine（Java虚拟机）的缩写。JVM是一个虚拟出来的计算机，有着自己的架构设计。

JVM的内存模型总体分为五个部分：堆、栈、方法区、程序计数器和本地方法栈。

<img src="https://s2.loli.net/2023/04/26/HRftqox3U2LKXb4.png" alt="image.png" style="zoom: 50%;" />

## 各区域的作用

### 堆(Heap)

在Java中，堆被划分成两个不同的区域：新生代(Young)、老年代(Old)和永久代。

#### 新生代(Young)

新生代又可以分为：Eden、From Survivor、To Survivor。

<img src="https://s2.loli.net/2023/04/26/vPp4KEB7Hn8VIuW.png" alt="image.png" style="zoom:50%;" />

堆时Java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，该区域存放对象实例以及数组。

新生代的区域配置一般是-Xms(最小值)和-Xmx(最大值)等进行参数设置，前者为启动的时候申请最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存，默认为物理内存的1/4。默认当空余堆内存小于40%时，JVM会增大堆内存到-Xmx指定的大小，如果需要进行验证则可以通过-XX:MinHeapFreeRation=来指定这个比例。

当空余堆内存大于70%时，JVM会减小堆内存的大小到-Xms指定的大小，可以通过-XX:MinHeapFreeRation=来指定这个比例，当然为了避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设为一样。`堆内存 = 新生代 + 老年代 + 持久代`。

在我们垃圾回收的时候，我们往往将堆内存分成新生代和老年代，新生代中由Eden和Survivor0，Survivor1组成，三者的比例是8：1：1，新生代的回收机制采用复制算法，在Minor GC的时候，我们都留一个存货区来存放活的对象，真正进行的区域是Eden+其中一个存货区，当我们的对象时长超过一定年龄时，将会把对象放入老年代，当然大的对象会直接进入老年代，老年代采用的回收算法是标记整理算法。

### 方法区(Method Area)

其实方法区是在JDK1.8前的版本里存在一块内存区域，主要存放从class文件里加载进来的类的，而且常量池也是在这块区域内的。

但是在JDK1.8之后，这块区域摇身一变，换个名字，叫做“Metaspace”，翻译过来就是“元数据空间”的意思，当然它只是改了个名，实现的功能是没变的。

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据。

<img src="https://s2.loli.net/2023/04/26/qjZuaDPnRUAFsoQ.png" alt="image.png" style="zoom:50%;" />

#### 1. 类型信息

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：

* 这个类型的完整有效名称
* 这个类型直接父类的完整有效名
* 这个类型的修饰符
* 这个类型直接接口的一个有序列表

#### 2. 域信息（field）成员变量

JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

域的相关信息包括：域名称、域类型、域修饰符。

#### 3.方法（Method）信息

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

* 方法名称
* 方法的返回类型，方法参数的数量和类型
* 方法的修饰符
* 方法的字节码、操作数栈、局部变量表及大小

### 虚拟机栈（JVM Stack）

虚拟机栈，早期也叫做Java栈，每个线程在创建都会创建一个新虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用。

虚拟机栈的作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的效用和返回。

每个方法被执行的时候都会创建一个`栈帧`，用于存储局部变量表（包含参数）、操作栈、方法出口等信息。

每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

栈帧（Stack Frame）是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟机栈的基本元素，栈帧由局部变量区、操作数栈等组成。

<img src="https://s2.loli.net/2023/04/27/oQrWGeO36pciStZ.png" alt="image.png" style="zoom:50%;" />

每个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。最顶部的栈帧称为当前栈帧，栈帧所关联的方法称为当前方法，定义这个方法的类称为当前类，该线程中，虚拟机有且只会对当前栈帧进行操作。

栈帧的作用存储数据，部分过程结果，处理动态链接，方法返回值和异常分派。

每个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈可以完全确定的，并写入到方法表的code属性中。

### 本地方法栈（Native Stack）

本地方法栈是为虚拟机使用到的Native方法服务。

虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。

与虚拟机栈一样，本地方法栈区域也会抛出OOM等异常。

### 程序计数器

在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

分支、循环、跳转、异常处理，线程恢复等基础功能都需要依赖这个计数器完成。

JVM的多线程是通过线程轮流切换分配处理执行时间的方式来实现的，为了各条线程之间的切换后计数器恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。

当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址：如果正在执行的是一个Native，那么这个计数器的值则为空。

程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OOM的区域。



















